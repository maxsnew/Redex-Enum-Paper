Thanks to the reviewers for their time, energy, and helpful
comments. For any comments that we don't address explicitly here, we
plan to follow the reviewers advice and generally use the comments in
the reviews to improve the paper. Thanks again.

Reviewers A and B ask about the subset of the combinators that our
formalization covers: we chose this subset because it covers the
portion of our library that is fair. It would be straightforward to
include all of the combinators of the library, but it distracts from
our focus on fairness.

Reviewer B asks a number of other excellent questions.

Reviewers B and D both correctly identify that our notion of fairness
is coarse, it does not rule out exponentially far apart equilibria or
even massively constantly far apart equilibria.

Our interest in fairness, however, is more focused on avoiding
unfairness. That is, much like how definitions of soundness must
reject some correct programs and don't generally specify how big or
useful the set of accepted programs is, we are concerned with avoiding
unfair enumerations as we know they are certainly problematic. We will
clarify this in the paper.

In addition, we can refine our notion of fairness to be parameterized
over a function characterizing when equilibria occur, as reviewer D
suggests. We like this suggestion and have worked this into our Coq
formalism. We updated the Coq proof to show explicitly that pairing
reaches equilibrium at (n+1)^2 and alternation reaches equilibrium at
2*(n+1).

Fairness for dependent enumerations and fairness generally: we have
thought about this some, but have not found a satisfactory way to
generalize our notion of fairness to dependency. And yes, fairness
doesn't compose; this is part of our interest in fairness. Like
soundness for type systems, it is not an obvious property of
enumeration combinators and it must be planned for from the start. We
see this as adding value to our work, helping others interested in
enumeration build better ones.

Traces: we agree that this additional instrumentation is awkward in
the formalism but it captures the precise property we are interested
in, so we use it.

Redex: we will work on the exposition in section 4.

Elias coding, etc: sampling using Elias codes seems similar to what
we're doing (choosing an exponent and the choosing the bits). The
geometric distribution is not a good choice as it will tend to choose
numbers near some fixed natural. Not having a fixed mean means that
the average of the first X samples is likely to be smaller than the
average of, say, the first 2*X samples (for any X).

Reviewer C asks about contracts: we use contracts because they are
like dependent types, giving us very fine-grained control, but
without having the proof burden (which would be difficult to
accommodate in the context of Redex).

Reviewer D points out errors in our bibliography: thanks! We will fix
them.

And finally, since the submission deadline we have learned that we
mischaracterized the original Feat work. In particular, it appears
that the enumerator for (Integer,(Integer,Integer)) does not use
nested pairing, contrary to our claim. The feat paper doesn't discuss
the concept of fairness nor does it provide any proofs, so we do not
think this error impacts the contribution of work. That said, we are
ashamed of this mistake and will correct it.

How fair Feat is depends on the underlying "cost" of constructors of a
datatype. Given a natural number type where each successor call
"costs" 1, pairing naturals reaches equilibria O(n^2) often. However,
if you think of them as having binary representation and the cost
being the number of bits needed to represent a number, then pairing
natural numbers reaches equilibria O(2^n) often.
